---
layout: post
title:  "[SOLID] 객체지향설계 5대 원칙"
date:   2019-01-16 08:43:59
author: chloe
categories: Spring, Throey
---

객체지향의 4대 특징(캡슐화, 다형성, 추상화, 상속)을 이용하여 객체 지향을 올바르게 설계할 수 있도록 도와주는 원칙에 대해 설명하고자 합니다.

`SOLID 설계원칙`은 자신의 클래스 안에 응집도는 높이고, 결합도는 낮추는 (High Cohesion - Loose coupling)원칙을 객체 지향의 관점에서 도입 것입니다.
SOLID 설계원칙 목표
1. 클래스 당 하나의 책임을 주어 독립된 모듈(클래스)를 만들기 위해서 입니다.
2. S/W의 재사용성을 높이고, 수정을 최소화하여 유지보수에 용이하게 하기 위함입니다.

#### OOP설계 5대원칙
- SRP (Single Responsibility Principle) 단일 책임 원칙
- OCP (Open-Closed Principle)           개방 폐쇄 원칙
- LSP (Liskov Substitution Principle)   리스코프 치환 원칙
- ISP (Interface Segregation Principle) 인터페이스 분리 원칙
- DIP (Dependency Inversion Principle)  의존 역전 원칙


##### SRP (Single Responsibility Principle, 단일 책임 원칙)
- 객체는 하나의 책임만을 맡아야한다. (억지로 나누지 말것)
- DB 정규화와 비슷하다. ( 성능저하라는 부작용이 없다.)
- 핵심 : 변화
- 목적 : 변화의 유연성 확보 ( 낮은 결합도, 높은 응집도 추구 )
- 사례 : 데이터 매퍼 패턴 (DAO)

##### OCP (Open-Closed Principle, 개방 패쇄 원칙)
- 모든 모듈은 확장에는 열려있어야 하고, 변경에는 닫혀있어야 한다.
- 방법 : 상위클래스 또는 인터페이스를 중간에 두어 직접적인 연동은 피하게 설계한다.<br/>
  1\.변화는(확장되는) 것과 변하지 않는 것을 엄격히 구분 후 이 두 모듈이 만나는 지점에 인터페이스를 정의<br/>
  2\.코드 수정이 없으면서 다른 제품과 연동된 확장적이게 된다. (상위클래스, 인터페이스는 `완충 장치` 역할을 한다.)
- 한번 설계되고 단위 테스트가 완료된 객체는, 향후 외부에 변경사항이 발생하더라도 객체 자체는 변경되지 않아야한다.
- 사례 : 상속과 어댑터 클래스를 통한 클라이언트 클래스 접속 , 컴파일러, POSIX 표준
- ex) 스트래티지 패턴 (클래스 자체를 참조하는 것이 아닌, 인터페이스를 참조하도록 한다.)


예시)
위 설계를 보면 PostgreSQL, Oracle, Sybase Database에 모두 확장적(개방)이면서 자바어플리케이션입장에서 수정은 폐쇄적인 것 임을 알아야 한다. 이것이 바로 OCP(개방 패쇄 원칙)이다.


##### LSP (Liskov Substitution Principle, 리스코프 치환 원칙)
- 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.<br/><br/>

상속의 잘못된 상식<br/>
하위클래스 is a kind of 상위 클래스이며, 계층구조가 아닌 분류이다.<br/>
상위 클래스, 하위클래스를 설계하는 것은 계층이 아닌 분류이며 상속=확장이라 생각해야한다.<br/>

##### ISP (Interface Segregation Principle, 인터페이스 분리 원칙)
- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.
- ISP(인터페이스 분리 원칙)은 SRP(단일 책임 원칙)과 같은 원인에 대한 다른 해결책을 제시하는 것이다.
- ISP(인터페이스 분리 원칙)은 해당 클래스를 그냥 냅 두는 상태에서 인터페이스 최소주의 원칙에 따라 각 상황에 맞는 기능만 제공하도록 필터링 한다고 생각하면 쉽다.

##### DIP (Dependency Inversion Principle, 의존 역전 원칙)
- 클라이언트는 구체 클래스가 아닌 인터페이스, 추상 클래스에 의존해야한다.
- Bridge 패턴처럼 인터페이스/추상클래스 간에만 서로 의존관계를 가지며 참조
- 모든 클래스에 인터페이스를 생성하면 클래스가 엄청나게 증가하고 복잡해지므로 필요한 것만 생성
-사례 : 이벤트 드리븐, 콜백, JMS, 통신 프로그래밍 모델
